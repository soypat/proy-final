\section{Desarrollo de software}

\subsection{Introducción a Software Engineering}

Hay una rama de ingeniería conocida como \textit{Software Engineering}. Se dice que el nombre fue concebido por Margaret Hamilton, una renombrada ingeniera de la NASA quien fue la principal contribuidora al software de la misión Apolo 11 entre 1961 y 1969. El término entro en prominencia en 1968 en una conferencia de la OTAN en Alemania. En la conferencia se discutió la crisis del software, la cual se refiere a la dificultad de escribir software de calidad en el tiempo y presupuesto asignado. Este documento estaba adelantado a su tiempo y es considerado un clásico en la ingeniería de software \citep{natoSoftwareEngineering}.

\medskip

El documento de la OTAN fue escrito por personalidades renombradas de la ciencia de la computación como Edger Djikstra, Doug Mccllroy, y Alan Perlis. Unos de los temas centrales que se discute es la complejidad de programas como una fuente de problemas. A continuación se citan algunos fragmentos del documento traducidos:
\begin{quote}
    Particularmente alarmante es la falabilidad inevitable de programas grandes, ya que una una falla en un sistema hardware-software avanzado puede ser la diferencia entre la vida y la muerte.

    -- David and Fraser
\end{quote}

\begin{quote}
   Estoy preocupado por el crecimiento actual de los sistemas [...] ¿Deberíamos tener sistemas de este tamaño y complejidad?

    -- Opler
\end{quote}

Cualquier persona que haya emprendido a diseñar un sistema complejo entiende de donde vienen estos comentarios. Aún teniendo un entendimiento profundo del problema a resolver y de las herramientas a usar, \textit{el diseño nunca deja de ser un proceso iterativo} [Kinslow] en donde la \textit{simplicidad y claridad de la solución se vuelve un objetivo central y crucial.}


\subsection{Tecnologías usadas}

La decisión de software a utilizar dependió del controlador, poder de cálculo disponible, interfases de periféricos y funcionalidad deseada.

\medskip

Dado el uso de una Raspberry Pi,\footnote{La Raspberry Pi provee un entorno con Linux instalado que permite la programación con virtualmente cualquier lenguaje de programación en existencia.} el lenguaje de programación elegido fue \textbf{Go} (Golang) debido a los siguientes puntos

\begin{description}
    \item[Seguro] - Modelo de memoria Go, sistema de tipado fuerte\footnote{Hoy en día hay pocos lenguajes con sistemas de tipos fuertes. Contrario a la creencia popular, C y C++ ambos son tipados débilmente (se puede castear tipos implicitamente sin errores de compilador).}
    \item[Legible] - Claridad de sintaxis 
    \item[Simple] - Solo 80 carillas de especificación comparado a 1700 de ISO C++.
    \item[Concurrencia] - Crear \glsplural{corrutina} es simple, paralelizar corrutinas es trivial
    \item[Rendimiento] - Superior a Python, Java y Matlab. Comparable a C. Esto también implica un menor consumo de energía \citep{pythonIsSlow}.\footnote{El autor reconoce que este documento tiene sus defectos al momento de evaluar los lenguajes de programación ya que los programas provistos al \textit{Benchmarks Game} están condicionados a ciertas reglas artificiales que no son representativos de lo que son capaces los lenguajes. Dicho esto el comentario sobre el rendimiento es válido en la experiencia del autor en base a programas reales escritos en Python, Matlab y Go. Cabe destacar que si a algún lenguaje no fue evaluado de forma favorable en el paper de Pereira es Go ya que varias soluciones mucho más efectivas fueron propuestas por la comunidad de Go pero descartadas por los autores del \textit{Benchamrks Game} por no manejar la memoria igual que otros lenguajes.}
    \item[Estable] - \textit{The Go 1 promise} (La promesa Go 1)
    \item[Comprobado] -  Usado en sistemas de alto-riesgo/alta-complejidad (Kubernetes, Docker, Go-HEP)
    \item[Portable] - Todos los programas Go compilan a código nativo (código de máquina) para cualquier arquitectura y sistema operativo. Incluso se puede programar microcontroladores (TinyGo)
\end{description}

\subsection{Flujo de control}
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.7\textwidth]{fig/cfg_flightprogram.eps}
    \caption{Gráfico de flujo de control (CFG) del programa de vuelo. Las lineas de flujo azules son corrutinas independientes al programa principal. Las lineas negras son flujo del programa principal. Las lineas rojas son flujo del programa principal al encontrar un error.}
    \label{fig:flightProgram}
\end{figure}

Se ilustra el flujo de control a grandes rasgos usando un CFG en la figura \ref{fig:flightProgram}. El programa principal corrió la rutina \texttt{overlord} que a su vez comandó \texttt{flightProgram} y esperó que esta devuelva control a \texttt{overlord}. El propósito de \texttt{overlord} fue guardar el estado del vehículo y ante una falla irrecuperable en \texttt{flightProgram}, terminar con todas las corrutinas generadas por \texttt{flightProgram} y sus afiliadas y a su vez reiniciar \texttt{flightProgram} nuevamente con el último estado antes de la falla.


\subsection{Interfaz con hardware}

Como se mencionó anteriormente, la computadora elegida tiene varios puertos que sirviern como interfases con periféricos, entre ellos 

\begin{itemize}
    \item ADC (sensores)
    \item Generadores de PWM (para actuadores)
    \item Blinkenlights
\end{itemize}

Para la interacción del software con el hardware se usó la librería \href{https://periph.io}{periph.io}. Esta librería permitió la interacción a través de los puertos de comunicación de la Raspberry Pi. Los drivers para los periféricos fueron programados según la información dada en las datasheet.


\subsection{Implementación}

Los siguientes datos son provistos para dar una idea de la complejidad del programa y de las capacidades de la computadora usada.

Al momento de escribir el presente informe el programa de vuelo tuvo 3540 líneas de lógica, de las cuales 1680 correspondieron a los drivers de control de periféricos.

Se logró controlar la actuación de hasta 12 señales PWM y en simultaneo leer 16 señales de telemetría y guardar a archivo en una tarjeta SD a 1200 muestras por segundo (cada canal). 1060 líneas de código fueron dedicadas a la interfaz de usuario para facilitar el control del vehículo desde un browser, como por ejemplo Firefox.

\subsection{Debugging}

En junio 2021 se halló un bug en el software. Al cabo de cierto tiempo entraba en un estado degenerado el sistema donde no respondía a inputs de usuario ni a señales del sistema operativo. Debido a los periféricos usados la última señal transmitida al actuador se quedaba fija y era imposible retornar el sistema a un estado seguro sin terminar el programa forzosamente y reiniciarlo. 

Se sospechaba que el bug era causa de una falla en el kernel de Linux para computadoras ARM o corrupción de memoria causada por el garbage collector de Go. Debido a la configuración de la computadora y las herramientas disponibles para Go era dificil debuggear. El debugger nativo de Go (Delve) no funcionaba aún en procesadores ARM de 32 bits y el detector de carreras de Go tampoco estaba disponible para procesadores ARM. Se pasó 6 meses investigando intermitentemente y hablando con expertos en software y hardware.

En enero 2022 se encontró el mismo comportamiento observado durante el bug mientras se desarrollaba un proyecto no asociado a este trabajo. En este software el estado degenerado era causado por una condición de carrera, específicamente era el caso de una \gls{datarace}. Con este conocimiento se modificó el programa de vuelo para que pueda correr en un entorno de computadora desktop. Para lograr esto se programó un mock de la escritura I2C que fue facilitado por el uso de \textit{interfaces} en Go. Esta modificación permitió al detector de carreras de Go encontrar condiciones de carrera en el programa de vuelo. Se encontraron y se arreglaron 2 condiciones de carreras causadas por error de programador debido al uso equivocado de mutexes.

Aún así el error persistía y el programa seguía encontrandosé en el estado degenerado. Se optó por reescribir el programa y aplicando patrones de diseño más estrictos y seguros en base a lo aprendido en el primer intento. Al cabo de un mes se había reescrito el programa de vuelo de la empresa y el bug no volvió a resurgir en el desarollo. Esto se puede deber a que se redujo el uso de librerias de terceros y la cantidad de líneas de código totales bajó de 700.000 a tan solo 30.000, incluyendo dependencias de terceros. Excluyendo las liberías de terceros, la base de código era de tan solo 2100 líneas e incluía el frontend (interfaz con el usuario). Esta reducción de lineas de código logró una reducción de complejidad enorme a la base de código y permitió que el programa de vuelo sea más fácil de debuggear y mantener, lo cual fue beneficioso para los programadores e incluso para la empresa ya que el programa sería mantenido por otros programadores en el futuro.

